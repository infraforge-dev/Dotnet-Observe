/// <summary>
/// Entry point for the dotnet-observe CLI tool.
/// This command-line application supports log tailing, filtering, and JSON output formatting
/// for structured log entries generated by the DotnetObserve middleware.
/// </summary>
/// <remarks>
/// Command: `tail`
/// 
/// Options:
///   - `--take`, `-n`: Limit the number of entries
///   - `--level`, `-l`: Filter logs by level (Info, Warn, Error, etc.)
///   - `--json`: Output format (pretty | compact)
///   - `--since`: Only logs with a timestamp after this value will be returned
/// </remarks>

using System.CommandLine;
using DotnetObserve.Core.Models;
using DotnetObserve.Core.Storage;
using DotnetObserve.Core.Constants;
using DotnetObserve.Cli.Utils;
using Spectre.Console;
using System.Text.Json;

// Determine log file path
var logPath = Path.GetFullPath(Path.Combine(AppContext.BaseDirectory, "../../../../SampleApi/logs.json"));
AnsiConsole.MarkupLine($"[grey]Looking for logs at:[/] {logPath}");

if (!File.Exists(logPath))
{
    AnsiConsole.MarkupLine("[red]❌ Log file not found![/]");
    return 1;
}

var logStore = new JsonFileStore<LogEntry>(logPath);

/// <summary>
/// Defines the 'tail' command used to stream and filter recent log entries.
/// </summary>
var tailCommand = new Command("tail", "Tail and display recent log entries");

// Define CLI options
var takeOption = new Option<int?>(
    aliases: new[] { "--take", "-n" },
    description: "How many log entries to show",
    getDefaultValue: () => 50
);

var levelOption = new Option<string>(
    aliases: new[] { "--level", "-l" },
    description: "Filter by log level (e.g., Info, Warn, Error)"
);

var jsonOption = new Option<string>(
    name: "--json",
    description: "Output log entries in JSON format. Options: 'pretty' or 'compact'"
);

var sinceOption = new Option<DateTimeOffset?>(
    name: "--since",
    description: "Only include logs after this UTC timestamp (e.g. 2025-06-17T08:00:00Z)"
);

// Attach options to command
tailCommand.AddOption(takeOption);
tailCommand.AddOption(levelOption);
tailCommand.AddOption(jsonOption);
tailCommand.AddOption(sinceOption);

/// <summary>
/// Main handler for the 'tail' command. Applies filters and outputs logs using
/// Spectre.Console or JSON formatting.
/// </summary>
tailCommand.SetHandler(async (take, level, jsonMode, since) =>
{
    var logs = await logStore.ReadAllAsync();

    if (!string.IsNullOrWhiteSpace(level) && !LogLevels.All.Contains(level))
    {
        AnsiConsole.MarkupLine($"[red]❌ Invalid log level:[/] {level}");
        AnsiConsole.MarkupLine($"[grey]Valid levels:[/] {string.Join(", ", LogLevels.All)}");
        return;
    }

    var filtered = LogFilter.Apply(
        logs.OrderByDescending(e => e.Timestamp),
        level,
        since
    ).Take(take ?? 50);

    var isPretty = string.Equals(jsonMode, "pretty", StringComparison.OrdinalIgnoreCase);
    var isCompact = string.Equals(jsonMode, "compact", StringComparison.OrdinalIgnoreCase);

    if (!string.IsNullOrWhiteSpace(jsonMode) && !isPretty && !isCompact)
    {
        AnsiConsole.MarkupLine("[red]❌ Invalid --json mode. Use 'pretty' or 'compact'.[/]");
    }

    foreach (var log in filtered)
    {
        if (!string.IsNullOrWhiteSpace(jsonMode))
        {
            var rawJson = JsonSerializer.Serialize(log, new JsonSerializerOptions
            {
                WriteIndented = isPretty
            });

            Console.WriteLine(rawJson);
        }
        else if (AnsiConsole.Profile.Capabilities.Ansi)
        {
            AnsiConsole.MarkupLine(LogFormatter.Format(log));
        }
        else
        {
            Console.WriteLine(LogFormatter.FormatPlainText(log));
        }
    }
}, takeOption, levelOption, jsonOption, sinceOption);

// Register root command
var rootCommand = new RootCommand("dotnet-observe CLI tool");
rootCommand.AddCommand(tailCommand);

// Execute
return await rootCommand.InvokeAsync(args);
